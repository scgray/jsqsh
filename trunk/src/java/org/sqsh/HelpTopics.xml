<Help>
	<Topic name="jni">
		<Description>Features provided by the jsqsh JNI layer</Description>
		<HelpText><![CDATA[
JSQSH JNI LAYER
    JSqsh is written in almost 100% java code, making it very 
    portable between platforms, however there are a few places 
    where java just does not provide enough functionality to 
    implement certain features that are needed by jsqsh, so jsqsh 
    can optinally load  a shared library (or DLL) that provides
    this additional  functionality. This shared library is
    written using the Java Native Interface (JNI) and on UNIX
    platforms is typically called 'libjsqsh.so' and on
    Windows is 'libjsqsh.dll'.
            
    The jsqsh shared library is not available on all platforms, and
    jsqsh will generate a warning upon startup if it is unable to
    load its JNI interface.  Lack of JNI causes the following
    behavior:
            
    - Operating system commands that are piped to (e.g. "go | grep ...")
      will not have direct access to the console (in the UNIX world
      this is called "tty" access). This means that these commands 
      cannot perform any console operations. Specifically, commands
      such as "more" will not function properly because "more" needs
      to query the console as to its size and will be unable to do so.
              
    - Similarly, the editor launched by \buf-edit will not have access
      to the console, so text-based editors such as 'vi' or 'emacs' 
      will not work properly. In this case, you will need to use a 
      graphical editor such as "notepad.exe" or "gvim".
		]]></HelpText>
</Topic>

<Topic name="welcome">
		<Description>The jsqsh welcome message</Description>
		<HelpText><![CDATA[
WELCOME TO JSQSH!
            
    It looks like this is the first time that you've run jsqsh (or
    you just typed '\help welcome' at the jsqsh prompt). If this is
    the first time you have run jsqsh, you will find that you have
    a shiney new directory called '.jsqsh' in your home directory
    and that this directory contains a couple of files that you
    should be aware of:
            
    drivers.xml - JSqsh comes pre-defined to understand how to use
       a fixed number of JDBC drivers, however this file may be
       used to teach it how to recognize other JDBC drivers. The
       file is pretty well commented, so hopefully it is enough
       to get you started.
               
    sqshrc - Everything contained in this file is executed just
       as if you had typed commands at the sqsh prompt and is 
       the place where you can set variables and configure sqsh
       to your likings.
               
    JSqsh is intended to be self-documenting. If you would like
    to see this information again, then type '\help welcome' at 
    the jsqsh prompt, or run '\help' to see a list of all help
    topics that are available.
	  ]]></HelpText>
</Topic>

<Topic name="buffers">
    <Description>SQL buffers and how they are referenced.</Description>
    <HelpText><![CDATA[
JSQSH SQL BUFFERS
    
    Each time you create and execute a SQL statement, that statement is saved
    away into your SQL buffer history. The list of prior SQL statements 
    can be displayed using the '\history' command.
    
    Many jsqsh command allow you to refer to SQL buffers via special syntax,
    each starting with an exclamation character (!).  This syntax allows for
    the following forms:
    
    !.   Refers to the current SQL buffer that you are currently 
         typing in to (but have not yet executed).
         
    !..  Refers to the most recently executed SQL buffer.
    
    !!   A synonym for "!..". In addition, typing "!!" at the prompt
         causes the current SQL buffer ("!.") to be appended with the
         most recently executed SQL statement. This is a useful feature
         for re-executing the previous statment. For example, to re-execute
         the most recently executed SQL statement:
         
           1> !!
           ...
           5> \go
           
         The "!!" appends the previously executed statement to the current
         buffer (which was empty) and the \go, obviously, executes the
         statement.
    
    !... Refers to the statement you executed two executions prior. Additional
         periods may be provided to continue moving back through executions 
         (e.g. !....... refers to the statement executed 6 executions prior).
         
    !N   This syntax allows you to refer to SQL statements executed a specific
         number of executions prior. For example "!0" refers to the current
         buffer (that has not yet been executed), "!1" refers to the 
         most recently execute statements, "!2" the one before that and so on.
         
EXAMPLES
    Examples of commands that utilize this syntax are \buf-edit, \but-copy,
    and \buf-append.  For example:
    
       \buf-edit !!
       
    indicats that the most recently executed statement should be edited.
	  ]]></HelpText>
</Topic>

<Topic name="license">
		<Description>Displays the jsqsh license</Description>
		<HelpText><![CDATA[
   Copyright 2007-2012 Scott C. Gray
  
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
  
       http://www.apache.org/licenses/LICENSE-2.0
  
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
	  ]]></HelpText>
</Topic>

<Topic name="contributors">
		<Description>Individuals who have contributed to jsqsh</Description>
		<HelpText><![CDATA[
JSQSH CONTRIBUTORS

   The following individuals have contributed to the development of
   jsqsh either by direct contribution of code, suggestions, or 
   inspiration.
   
   Walter Jordan <walter.gator at gmail.com>
       Patches and useful suggestions.
       
   Ryan Stouffer <rstouffer at inventa.com>
       Enhancements and additions to GUI widgets.
	  ]]></HelpText>
</Topic>

<Topic name="options">
		<Description>Command line option processing</Description>
		<HelpText><![CDATA[
COMMAND LINE OPTIONS
   Jsqsh commands executed on the jsqsh command line follow many 
   of the same rules as program executed at your computers command
   line (well, unless you are used to working in the Windows 
   command shell, then you'll find it is better).
   
   All jsqsh commands accept command line options. These options
   are provided in two different forms: a short form an a long form.
   
SHORT OPTIONS
   Short command line options are provided in the form of a dash (-)
   followed by a letter. For example, the \connect command requires
   a username to be used to establish a connection to the database
   server.  The short form of this option is "-U" followed by the name
   of the user. You can either have a space following the username or 
   not, so that:
   
      \connect -Usgray
      
   is the same as:
   
      \connect -U sgray

   In some cases, the command line option does not take an argument 
   (in the above "sgray" was the argument to the -U option). For 
   example, with the \echo command:
   
      \echo -n hello
      
   the '-n' flag indicates that a new-line should NOT be displayed
   after printing the word "hello" 
   
LONG OPTIONS
   Short options are easy to enter, but for command, such as \connect,
   which require a lot of options, it can begin to look like alphabet
   soup:
   
      \connect -Usa -Pguessme -Dmaster -Ssql-prod -dmssql-jtds
   
   To address this, every command line option also has an alternate
   long form. For example, the equivalent of the -U option for 
   \connect is (note the double-dashes, they indicate it is a long option):
   
      \connect --user=sgray
   
   or
   
      \connect --user sgray
      
   this, the full command line shown above would be:
   
      \connect --user=sa --password=guessme --database=master
               --server=sql-prod --driver=mssql-jtds
   
   this form may take more typing but is much more explicit.
   
OPTION DOCUMENTATION
   In all help documents, options are generally shown as:
   
      -X, --long-name1=value
   
   where the option -X is also known as --long-name1 and takes
   an argument (e.g. "-X value", "-Xvalue", "--long-name1=value"
   or "--long-name1 value" are all the same).
   
      -Y, --long-name2[=value]
      
   where the option -Y is also known as --long-name2 and has
   a value that is not required. 
   
      -Z, --long-name3
    
   where the option -Z is also known as --long-name3 and does
   not have an argument (e.g. "-Z", or "--long-name3" are the same)
      
OPTIONS SUPPORTED BY ALL COMMANDS
   All jsqsh commands accept the following arguments:
   
   -g, --gui   Display all output in a graphical popup window. This is 
               useful for setting aside a result set for later reference
               while you continue to work.
               
   -h, --help  Displays a description how to execute the command.
	  ]]></HelpText>
</Topic>

<Topic name="redirection">
		<Description>Command line output redirection</Description>
		<HelpText><![CDATA[
COMMAND LINE REDIRECTION
    As with standard Bourne shell (and most other shells, for that 
    matter), a command's output may be redirected using a special
    notation interpreted by the jsqsh. The following may appear anywhere
    on the command line, but only redirection that is specified prior
    to a pipe (|) actually has any effect on the behavior of internal
    jsqsh commands.
    
    [n]>file  Causes the output of the command to be redirected to a 
              file.  Following standard shell conventions, the "n" is 
              an optional number that can be used to indicate which
              output of the command is redirected to the file.  A "1"
              indicates the regular output should be redirected, and
              a "2" indicates only the errors should be redirected.
              If no number is provided, then regular output is diverted.
              
              For example:
              
              \go >tmp.out  Sends the output of the "\go" command
                            to a file called tmp.out. Errors will still
                            go to your screen.
                            
              \go 1>tmp.out Synonym for the above.
                            
              \go 2>tmp.out The results from the \go will go to your screen
                            but errors will be captured in tmp.out.
    
    [n]>>file This is identical to the above except that if the file 
              exists, it is appended to rather than overwritten.
    
    [m]>&[n]  This allows one type of output stream (regular output
              or errors) to be redirected to the other type of stream.
              For example:
              
              \go 2>&1      Causes errors from the SQL to go to the
                            regular output stream
              
              \echo "Error!" 1>&2 
                            Causes the output of the \echo command to
                            be send to the error stream.
                            
              \echo "Error!" >&2 
                            A synonym for the above.
   
    >+[id]   This syntax is specific to jsqsh and is used to redirect the
             output from the current command to the context of another 
             session (specified by "id"). If no session id is provided,
             then the output of the current session is "looped back" to itself.
             See SESSION REDIRECTION, below for details.
             
PIPES AND REDIRECTION
    It is important to understand that jsqsh handles pipes very differently
    from that of a typical shell. In jsqsh anything following a pipe 
    character (|) is passed directly to the operating system shell, which
    means that any I/O redirection following the pipe character is being
    performed by your local operating system shell and not by jsqsh and will
    therefore follow whatever rules are defined by your O/S shell.

SESSION REDIRECTION
    Session redirection is indicated by the special syntax ">+[id]" where
    "id" is the id of the session that you wish to re-direct the output to.
    If the id is not specified then the output is sent back to your current
    session for subsequent processing.
    
    When jsqsh encounters a session redirection the following takes place:
    
    1. A temporary file is created and the commands output is sent to
       that file.
    2. If the command involves a pipe, the output of the pipe is sent to
       that file.
    3. After the command completes, the contents of the file is executed
       in the context of the target session as if:
       
           \eval <tmp_file>
       
       was executed in the target session.
       
    The important item to note is that any output from the command being
    directed is treated *exactly* as if the user had typed it into the
    prompt in the context of the target session.
    
    Here's why this is so important to understand:
    
       1> echo 'select 1' >+2 
       
    will *not* cause a "select 1" to be executed in session #2. All that
    will happen is that jsqsh will switch to the context of session #2,
    pretend that the user has typed "select 1", and then switch back to the
    current session.  The end result, is that a "select 1" will be appended
    to the current SQL buffer (the SQL buffer is independant of sessions).
    
    If you actually want to execute the command then you can do one of two
    things:
    
       1> echo 'select 1;' >+ 2
       
    or 
    
       1> echo 'select 1' >+2
       2> \echo 'go' >+2
       
    In the first case, the semicolon causes the execution of the SQL
    and in the second, the "go" executed in the context of session #2
    causes the execution.
	  ]]></HelpText>
</Topic>

<Topic name="editing">
        <Description>JSqsh line editing</Description>
        <HelpText><![CDATA[
JSQSH LINE EDITING
   Jsqsh can utilize several different line editing libraries that allow
   you to move around and edit the current line you are typing at, as well
   as to scroll backwards and forwards through previous lines of text
   that you have typed in.  Note that this is different from recalling
   and editing entire statements: for that, please see the \help for 
   "buffers" "history", and "buf-edit".

CHOOSING A LINE EDITOR
   JSqsh uses JLine as the default line editor (see below).  However,
   it supports a number of editors, You can control which editor is used 
   via either the "--readline" command line option when starting jsqsh, 
   or the JSQSH_READLINE environment variable, so to one of the values 
   below:

      * jline    - JLine (built-in)
      * readline - GNU Readline (via java-readline, see below)
      * editline - BSD Editline (via java-readline, see below)
      * getline  - Getline (via java-readline, see below)
      * none     - None (no line editor)

JLINE LINE EDITING
   As of JSqsh 1.5, the default line editor is JLine:

       https://github.com/jline/jline2

   This library provides full line editing, history recall, searching,
   emacs and vi keymaps, configurable keymaps and a bunch of other 
   functionality.  The JLine library is not 100% java and relies upon
   some native code.  As a result, it is only supported on Windows (32
   and 64 bit), Linux (32 and 64 bit) and MacOS.

GNU READLINE SUPPORT
   GNU readline used to be the default editor in JSqsh, however as of
   JSqsh 1.5, JLine is now the default and readline is not included
   with the JSqsh distribution. This was due to both the JSqsh license 
   change to the Apache license, as well as to the fact that the 
   Java-Readline library appears to be abandoned. 

   While Jsqsh retains its support for Java-Readline, the library
   is not included with the jsqsh distribution.  If you wish to utilize
   the library, most Linux distributions can easily install
   Java-Readline using the software package manager (typically under
   a package named "libreadline-java").

   JAVA-READLINE DETECTION
   
   The JSqsh startup script will automaticallyl detect and utilize
   java-readline if it is installed on your system on a debian based
   linux distribution (e.g. Debian, Ubuntu, Mint, etc.).  
   If these are found, then readline support will be enabled. 
      ]]></HelpText>
</Topic>

<Topic name="contributors">
        <Description>Individuals who have contributed to jsqsh</Description>
        <HelpText><![CDATA[
JSQSH CONTRIBUTORS

   The following individuals have contributed to the development of jsqsh
   inspiration.
   
   Walter Jordan <walter.gator at gmail.com>
       Patches and useful suggestions.
       
   Ryan Stouffer <rstouffer at inventa.com>
       Enhancements and additions to GUI widgets.
      ]]></HelpText>
</Topic>

</Help>

<Help>
	<Topic name="jni">
		<Description>Features provided by the jsqsh JNI layer</Description>
		<HelpText><![CDATA[
JSQSH JNI LAYER
    JSqsh is written in almost 100% java code, making it very 
    portable between platforms, however there are a few places 
    where java just does not provide enough functionality to 
    implement certain features that are needed by jsqsh, so jsqsh 
    can optinally load  a shared library (or DLL) that provides
    this additional  functionality. This shared library is
    written using the Java Native Interface (JNI) and on UNIX
    platforms is typically called 'libjsqsh.so' and on
    Windows is 'libjsqsh.dll'.
            
    The jsqsh shared library is not available on all platforms, and
    jsqsh will generate a warning upon startup if it is unable to
    load its JNI interface.  Lack of JNI causes the following
    behavior:
            
    - Operating system commands that are piped to (e.g. "go | grep ...")
      will not have direct access to the console (in the UNIX world
      this is called "tty" access). This means that these commands 
      cannot perform any console operations. Specifically, commands
      such as "more" will not function properly because "more" needs
      to query the console as to its size and will be unable to do so.
              
    - Similarly, the editor launched by \buf-edit will not have access
      to the console, so text-based editors such as 'vi' or 'emacs' 
      will not work properly. In this case, you will need to use a 
      graphical editor such as "notepad.exe" or "gvim".
		]]></HelpText>
</Topic>

<Topic name="welcome">
		<Description>The jsqsh welcome message</Description>
		<HelpText><![CDATA[
WELCOME TO JSQSH!
            
    It looks like this is the first time that you've run jsqsh (or
    you just typed '\help welcome' at the jsqsh prompt). If this is
    the first time you have run jsqsh, you will find that you have
    a shiney new directory called '.jsqsh' in your home directory
    and that this directory contains a couple of files that you
    should be aware of:
            
    drivers.xml - JSqsh comes pre-defined to understand how to use
       a fixed number of JDBC drivers, however this file may be
       used to teach it how to recognize other JDBC drivers. The
       file is pretty well commented, so hopefully it is enough
       to get you started.
               
    sqshrc - Everything contained in this file is executed just
       as if you had typed commands at the sqsh prompt and is 
       the place where you can set variables and configure sqsh
       to your likings.
               
    JSqsh is intended to be self-documenting. If you would like
    to see this information again, then type '\help welcome' at 
    the jsqsh prompt, or run '\help' to see a list of all help
    topics that are available.
	  ]]></HelpText>
</Topic>

<Topic name="buffers">
		<Description>SQL buffers and how they are referenced.</Description>
		<HelpText><![CDATA[
JSQSH SQL BUFFERS
    
    Each time you create and execute a SQL statement, that statement is saved
    away into your SQL buffer history. The list of prior SQL statements 
    can be displayed using the '\history' command.
    
    Many jsqsh command allow you to refer to SQL buffers via special syntax,
    each starting with an esclamation character (!).  This syntax allows for
    the following forms:
    
    !.   Refers to the current SQL buffer that you are currently 
         typing in to (but have not yet executed).
         
    !..  Refers to the most recently executed SQL buffer.
    
    !!   A synonym for "!..". In addition, typing "!!" at the prompt
         causes the current SQL buffer ("!.") to be appended with the
         most recently executed SQL statement. This is a useful feature
         for re-executing the previous statment. For example, to re-execute
         the most recently executed SQL statement:
         
           1> !!
           ...
           5> \go
           
         The "!!" appends the previously executed statement to the current
         buffer (which was empty) and the \go, obviously, executes the
         statement.
    
    !... Refers to the statement you executed two executions prior. Additional
         periods may be provided to continue moving back through executions 
         (e.g. !....... refers to the statement executed 6 executions prior).
         
    !N   This syntax allows you to refer to SQL statements executed a specific
         number of executions prior. For example "!0" refers to the current
         buffer (that has not yet been executed), "!1" refers to the 
         most recently execute statements, "!2" the one before that and so on.
         
EXAMPLES
    Examples of commands that utilize this syntax are \buf-edit, \but-copy,
    and \buf-append.  For example:
    
       \buf-edit !!
       
    indicats that the most recently executed statement should be edited.
	  ]]></HelpText>
</Topic>

<Topic name="license">
		<Description>Displays the jsqsh license</Description>
		<HelpText><![CDATA[
JSQSH GNU PUBLIC LICENSE		

   JSqsh, Copyright (C) 2007 by Scott C. Gray

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program. If not, write to the Free Software
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
	  ]]></HelpText>
</Topic>

<Topic name="readline">
		<Description>Describes jsqsh's use of GNU Readline</Description>
		<HelpText><![CDATA[
GNU READLINE SUPPORT

   The GNU Readline library provides support for command line editing features,
   allowing the user to scroll back and forth through the history of lines
   that they have typed and remembering those lines between sessions with
   jsqsh.  
   
   The readline library is a native C library that jsqsh utilizes 
   via JNI (Java Native Interface) and may or may not be available or
   installed on your platform. If the library is not installed or jsqsh
   cannot load it you will receive a message:
   
     WARNING: Unable to load GNU Readline library (no JavaReadline in
        java.library.path). Run '\help readline' for details.
        
   If you receive this message, then you first want to ensure that you have
   the readline library installed on your system. The library is available
   from:
   
      http://tiswww.case.edu/php/chet/readline/rltop.html
      
   You'll also want to refer to the site above for details on configuration
   and utilization of readline.
      
   All Linux systems and most other UNIX systems should already have this
   library installed or readily installable via your distributions package
   manager (on Debian distributions the package is 'libreadline5')
   
   Next, you'll need to ensure that you have the readline JNI library 
   installed on your system. This library is available from:
   
      http://java-readline.sourceforge.net/
      
   Again, many Linux distributions have this library available in a pre-
   packaged version (on Debian distributions, the package is 
   'libreadline-java').
   
   Finally, you'll need to ensure that both libraries can be found by jsqsh.
   On most UNIX distributions, this means setting your LD_LIBRARY_PATH
   environment variable to point to the directories containing the libraries.
   On my Ubuntu distribution, my LD_LIBRARY_PATH contains:
   
        LD_LIBRARY_PATH=/usr/lib/jni
	  ]]></HelpText>
</Topic>

<Topic name="contributors">
		<Description>Individuals who have contributed to jsqsh</Description>
		<HelpText><![CDATA[
JSQSH CONTRIBUTORS

   The following individuals have contributed to the development of
   jsqsh either by direct contribution of code, suggestions, or 
   inspiration.
   
   Henner Zeller <h.zeller at acm.org>
       Developer of HenPlus (http://henplus.sourceforge.net/). HenPlus was
       the inspiration for development of jsqsh--a demonstration that a
       reasonable command line interface can be built with Java.
       
   Walter Jordan <walter.gator at gmail.com>
       Patches and useful suggestions.
	  ]]></HelpText>
</Topic>

<Topic name="options">
		<Description>Command line option processing</Description>
		<HelpText><![CDATA[
COMMAND LINE OPTIONS
   Jsqsh commands executed on the jsqsh command line follow many 
   of the same rules as program executed at your computers command
   line (well, unless you are used to working in the Windows 
   command shell, then you'll find it is better).
   
   All jsqsh commands accept command line options. These options
   are provided in two different forms: a short form an a long form.
   
SHORT OPTIONS
   Short command line options are provided in the form of a dash (-)
   followed by a letter. For example, the \connect command requires
   a username to be used to establish a connection to the database
   server.  The short form of this option is "-U" followed by the name
   of the user. You can either have a space following the username or 
   not, so that:
   
      \connect -Usgray
      
   is the same as:
   
      \connect -U sgray

   In some cases, the command line option does not take an argument 
   (in the above "sgray" was the argument to the -U option). For 
   example, with the \echo command:
   
      \echo -n hello
      
   the '-n' flag indicates that a new-line should NOT be displayed
   after printing the word "hello" 
   
LONG OPTIONS
   Short options are easy to enter, but for command, such as \connect,
   which require a lot of options, it can begin to look like alphabet
   soup:
   
      \connect -Usa -Pguessme -Dmaster -Ssql-prod -dmssql-jtds
   
   To address this, every command line option also has an alternate
   long form. For example, the equivalent of the -U option for 
   \connect is (note the double-dashes, they indicate it is a long option):
   
      \connect --user=sgray
   
   or
   
      \connect --user sgray
      
   this, the full command line shown above would be:
   
      \connect --user=sa --password=guessme --database=master
               --server=sql-prod --driver=mssql-jtds
   
   this form may take more typing but is much more explicit.
   
OPTION DOCUMENTATION
   In all help documents, options are generally shown as:
   
      -X, --long-name1=value
   
   where the option -X is also known as --long-name1 and takes
   an argument (e.g. "-X value", "-Xvalue", "--long-name1=value"
   or "--long-name1 value" are all the same).
   
      -Y, --long-name2[=value]
      
   where the option -Y is also known as --long-name2 and has
   a value that is not required. 
   
      -Z, --long-name3
    
   where the option -Z is also known as --long-name3 and does
   not have an argument (e.g. "-Z", or "--long-name3" are the same)
      
OPTIONS SUPPORTED BY ALL COMMANDS
   All jsqsh commands accept the following arguments:
   
   -g, --gui   Display all output in a graphical popup window. This is 
               useful for setting aside a result set for later reference
               while you continue to work.
               
   -h, --help  Displays a description how to execute the command.
	  ]]></HelpText>
</Topic>

</Help>